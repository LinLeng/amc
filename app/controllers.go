// Code generated by goagen v1.2.0-dirty, DO NOT EDIT.
//
// API "amc": Application Controllers
//
// Command:
// $ goagen
// --design=github.com/citrusleaf/amc/api_design
// --out=$(GOPATH)/src/github.com/citrusleaf/amc/temp
// --version=v1.2.0-dirty

package app

import (
	"context"
	"github.com/goadesign/goa"
	"github.com/goadesign/goa/cors"
	"net/http"
)

// initService sets up the service encoders, decoders and mux.
func initService(service *goa.Service) {
	// Setup encoders and decoders
	service.Encoder.Register(goa.NewJSONEncoder, "application/json")
	service.Decoder.Register(goa.NewJSONDecoder, "application/json")

	// Setup default encoder and decoder
	service.Encoder.Register(goa.NewJSONEncoder, "*/*")
	service.Decoder.Register(goa.NewJSONDecoder, "*/*")
}

// AmcController is the controller interface for the Amc actions.
type AmcController interface {
	goa.Muxer
	System(*SystemAmcContext) error
}

// MountAmcController "mounts" a Amc resource controller on the given service.
func MountAmcController(service *goa.Service, ctrl AmcController) {
	initService(service)
	var h goa.Handler
	service.Mux.Handle("OPTIONS", "/api/v1/amc/system", ctrl.MuxHandler("preflight", handleAmcOrigin(cors.HandlePreflight()), nil))

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewSystemAmcContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.System(rctx)
	}
	h = handleAmcOrigin(h)
	service.Mux.Handle("GET", "/api/v1/amc/system", ctrl.MuxHandler("system", h, nil))
	service.LogInfo("mount", "ctrl", "Amc", "action", "System", "route", "GET /api/v1/amc/system")
}

// handleAmcOrigin applies the CORS response headers corresponding to the origin.
func handleAmcOrigin(h goa.Handler) goa.Handler {

	return func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		origin := req.Header.Get("Origin")
		if origin == "" {
			// Not a CORS request
			return h(ctx, rw, req)
		}
		if cors.MatchOrigin(origin, "*") {
			ctx = goa.WithLogContext(ctx, "origin", origin)
			rw.Header().Set("Access-Control-Allow-Origin", origin)
			rw.Header().Set("Access-Control-Expose-Headers", "X-Time")
			rw.Header().Set("Access-Control-Max-Age", "600")
			rw.Header().Set("Access-Control-Allow-Credentials", "true")
			if acrm := req.Header.Get("Access-Control-Request-Method"); acrm != "" {
				// We are handling a preflight request
				rw.Header().Set("Access-Control-Allow-Methods", "GET, POST, DELETE")
				rw.Header().Set("Access-Control-Allow-Headers", "*")
			}
			return h(ctx, rw, req)
		}

		return h(ctx, rw, req)
	}
}

// AuthController is the controller interface for the Auth actions.
type AuthController interface {
	goa.Muxer
	Authenticate(*AuthenticateAuthContext) error
}

// MountAuthController "mounts" a Auth resource controller on the given service.
func MountAuthController(service *goa.Service, ctrl AuthController) {
	initService(service)
	var h goa.Handler
	service.Mux.Handle("OPTIONS", "/api/v1/auth/authenticate", ctrl.MuxHandler("preflight", handleAuthOrigin(cors.HandlePreflight()), nil))

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewAuthenticateAuthContext(ctx, req, service)
		if err != nil {
			return err
		}
		// Build the payload
		if rawPayload := goa.ContextRequest(ctx).Payload; rawPayload != nil {
			rctx.Payload = rawPayload.(*AuthenticateAuthPayload)
		} else {
			return goa.MissingPayloadError()
		}
		return ctrl.Authenticate(rctx)
	}
	h = handleAuthOrigin(h)
	service.Mux.Handle("POST", "/api/v1/auth/authenticate", ctrl.MuxHandler("authenticate", h, unmarshalAuthenticateAuthPayload))
	service.LogInfo("mount", "ctrl", "Auth", "action", "Authenticate", "route", "POST /api/v1/auth/authenticate")
}

// handleAuthOrigin applies the CORS response headers corresponding to the origin.
func handleAuthOrigin(h goa.Handler) goa.Handler {

	return func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		origin := req.Header.Get("Origin")
		if origin == "" {
			// Not a CORS request
			return h(ctx, rw, req)
		}
		if cors.MatchOrigin(origin, "*") {
			ctx = goa.WithLogContext(ctx, "origin", origin)
			rw.Header().Set("Access-Control-Allow-Origin", origin)
			rw.Header().Set("Access-Control-Expose-Headers", "X-Time")
			rw.Header().Set("Access-Control-Max-Age", "600")
			rw.Header().Set("Access-Control-Allow-Credentials", "true")
			if acrm := req.Header.Get("Access-Control-Request-Method"); acrm != "" {
				// We are handling a preflight request
				rw.Header().Set("Access-Control-Allow-Methods", "GET, POST, DELETE")
				rw.Header().Set("Access-Control-Allow-Headers", "*")
			}
			return h(ctx, rw, req)
		}

		return h(ctx, rw, req)
	}
}

// unmarshalAuthenticateAuthPayload unmarshals the request body into the context request data Payload field.
func unmarshalAuthenticateAuthPayload(ctx context.Context, service *goa.Service, req *http.Request) error {
	payload := &authenticateAuthPayload{}
	if err := service.DecodeRequest(req, payload); err != nil {
		return err
	}
	if err := payload.Validate(); err != nil {
		// Initialize payload with private data structure so it can be logged
		goa.ContextRequest(ctx).Payload = payload
		return err
	}
	goa.ContextRequest(ctx).Payload = payload.Publicize()
	return nil
}

// BackupController is the controller interface for the Backup actions.
type BackupController interface {
	goa.Muxer
	Create(*CreateBackupContext) error
	Progress(*ProgressBackupContext) error
	Query(*QueryBackupContext) error
	Show(*ShowBackupContext) error
}

// MountBackupController "mounts" a Backup resource controller on the given service.
func MountBackupController(service *goa.Service, ctrl BackupController) {
	initService(service)
	var h goa.Handler
	service.Mux.Handle("OPTIONS", "/api/v1/connections/:connId/backups", ctrl.MuxHandler("preflight", handleBackupOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/connections/:connId/backups/progress", ctrl.MuxHandler("preflight", handleBackupOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/connections/:connId/backups/:backupId", ctrl.MuxHandler("preflight", handleBackupOrigin(cors.HandlePreflight()), nil))

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewCreateBackupContext(ctx, req, service)
		if err != nil {
			return err
		}
		// Build the payload
		if rawPayload := goa.ContextRequest(ctx).Payload; rawPayload != nil {
			rctx.Payload = rawPayload.(*CreateBackupPayload)
		} else {
			return goa.MissingPayloadError()
		}
		return ctrl.Create(rctx)
	}
	h = handleSecurity("jwt", h, "api:enterprise")
	h = handleBackupOrigin(h)
	service.Mux.Handle("POST", "/api/v1/connections/:connId/backups", ctrl.MuxHandler("create", h, unmarshalCreateBackupPayload))
	service.LogInfo("mount", "ctrl", "Backup", "action", "Create", "route", "POST /api/v1/connections/:connId/backups", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewProgressBackupContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Progress(rctx)
	}
	h = handleSecurity("jwt", h, "api:enterprise")
	h = handleBackupOrigin(h)
	service.Mux.Handle("GET", "/api/v1/connections/:connId/backups/progress", ctrl.MuxHandler("progress", h, nil))
	service.LogInfo("mount", "ctrl", "Backup", "action", "Progress", "route", "GET /api/v1/connections/:connId/backups/progress", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewQueryBackupContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Query(rctx)
	}
	h = handleSecurity("jwt", h, "api:enterprise")
	h = handleBackupOrigin(h)
	service.Mux.Handle("GET", "/api/v1/connections/:connId/backups", ctrl.MuxHandler("query", h, nil))
	service.LogInfo("mount", "ctrl", "Backup", "action", "Query", "route", "GET /api/v1/connections/:connId/backups", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewShowBackupContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Show(rctx)
	}
	h = handleSecurity("jwt", h, "api:enterprise")
	h = handleBackupOrigin(h)
	service.Mux.Handle("GET", "/api/v1/connections/:connId/backups/:backupId", ctrl.MuxHandler("show", h, nil))
	service.LogInfo("mount", "ctrl", "Backup", "action", "Show", "route", "GET /api/v1/connections/:connId/backups/:backupId", "security", "jwt")
}

// handleBackupOrigin applies the CORS response headers corresponding to the origin.
func handleBackupOrigin(h goa.Handler) goa.Handler {

	return func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		origin := req.Header.Get("Origin")
		if origin == "" {
			// Not a CORS request
			return h(ctx, rw, req)
		}
		if cors.MatchOrigin(origin, "*") {
			ctx = goa.WithLogContext(ctx, "origin", origin)
			rw.Header().Set("Access-Control-Allow-Origin", origin)
			rw.Header().Set("Access-Control-Expose-Headers", "X-Time")
			rw.Header().Set("Access-Control-Max-Age", "600")
			rw.Header().Set("Access-Control-Allow-Credentials", "true")
			if acrm := req.Header.Get("Access-Control-Request-Method"); acrm != "" {
				// We are handling a preflight request
				rw.Header().Set("Access-Control-Allow-Methods", "GET, POST, DELETE")
				rw.Header().Set("Access-Control-Allow-Headers", "*")
			}
			return h(ctx, rw, req)
		}

		return h(ctx, rw, req)
	}
}

// unmarshalCreateBackupPayload unmarshals the request body into the context request data Payload field.
func unmarshalCreateBackupPayload(ctx context.Context, service *goa.Service, req *http.Request) error {
	payload := &createBackupPayload{}
	if err := service.DecodeRequest(req, payload); err != nil {
		return err
	}
	if err := payload.Validate(); err != nil {
		// Initialize payload with private data structure so it can be logged
		goa.ContextRequest(ctx).Payload = payload
		return err
	}
	goa.ContextRequest(ctx).Payload = payload.Publicize()
	return nil
}

// ConnectionController is the controller interface for the Connection actions.
type ConnectionController interface {
	goa.Muxer
	AddNode(*AddNodeConnectionContext) error
	Config(*ConfigConnectionContext) error
	Connect(*ConnectConnectionContext) error
	Delete(*DeleteConnectionContext) error
	Entities(*EntitiesConnectionContext) error
	Latency(*LatencyConnectionContext) error
	Namespaces(*NamespacesConnectionContext) error
	Query(*QueryConnectionContext) error
	Save(*SaveConnectionContext) error
	SetConfig(*SetConfigConnectionContext) error
	Show(*ShowConnectionContext) error
	Throughput(*ThroughputConnectionContext) error
}

// MountConnectionController "mounts" a Connection resource controller on the given service.
func MountConnectionController(service *goa.Service, ctrl ConnectionController) {
	initService(service)
	var h goa.Handler
	service.Mux.Handle("OPTIONS", "/api/v1/connections/:connId/add-node", ctrl.MuxHandler("preflight", handleConnectionOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/connections/:connId/config", ctrl.MuxHandler("preflight", handleConnectionOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/connections/:connId", ctrl.MuxHandler("preflight", handleConnectionOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/connections/:connId/entity-tree", ctrl.MuxHandler("preflight", handleConnectionOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/connections/:connId/latency", ctrl.MuxHandler("preflight", handleConnectionOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/connections/:connId/namespaces", ctrl.MuxHandler("preflight", handleConnectionOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/connections", ctrl.MuxHandler("preflight", handleConnectionOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/connections/:connId/throughput", ctrl.MuxHandler("preflight", handleConnectionOrigin(cors.HandlePreflight()), nil))

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewAddNodeConnectionContext(ctx, req, service)
		if err != nil {
			return err
		}
		// Build the payload
		if rawPayload := goa.ContextRequest(ctx).Payload; rawPayload != nil {
			rctx.Payload = rawPayload.(*AddNodeConnectionPayload)
		} else {
			return goa.MissingPayloadError()
		}
		return ctrl.AddNode(rctx)
	}
	h = handleSecurity("jwt", h, "api:enterprise")
	h = handleConnectionOrigin(h)
	service.Mux.Handle("POST", "/api/v1/connections/:connId/add-node", ctrl.MuxHandler("add-node", h, unmarshalAddNodeConnectionPayload))
	service.LogInfo("mount", "ctrl", "Connection", "action", "AddNode", "route", "POST /api/v1/connections/:connId/add-node", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewConfigConnectionContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Config(rctx)
	}
	h = handleSecurity("jwt", h, "api:enterprise")
	h = handleConnectionOrigin(h)
	service.Mux.Handle("GET", "/api/v1/connections/:connId/config", ctrl.MuxHandler("config", h, nil))
	service.LogInfo("mount", "ctrl", "Connection", "action", "Config", "route", "GET /api/v1/connections/:connId/config", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewConnectConnectionContext(ctx, req, service)
		if err != nil {
			return err
		}
		// Build the payload
		if rawPayload := goa.ContextRequest(ctx).Payload; rawPayload != nil {
			rctx.Payload = rawPayload.(*ConnectConnectionPayload)
		} else {
			return goa.MissingPayloadError()
		}
		return ctrl.Connect(rctx)
	}
	h = handleSecurity("jwt", h, "api:general")
	h = handleConnectionOrigin(h)
	service.Mux.Handle("POST", "/api/v1/connections/:connId", ctrl.MuxHandler("connect", h, unmarshalConnectConnectionPayload))
	service.LogInfo("mount", "ctrl", "Connection", "action", "Connect", "route", "POST /api/v1/connections/:connId", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewDeleteConnectionContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Delete(rctx)
	}
	h = handleSecurity("jwt", h, "api:general")
	h = handleConnectionOrigin(h)
	service.Mux.Handle("DELETE", "/api/v1/connections/:connId", ctrl.MuxHandler("delete", h, nil))
	service.LogInfo("mount", "ctrl", "Connection", "action", "Delete", "route", "DELETE /api/v1/connections/:connId", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewEntitiesConnectionContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Entities(rctx)
	}
	h = handleSecurity("jwt", h, "api:general")
	h = handleConnectionOrigin(h)
	service.Mux.Handle("GET", "/api/v1/connections/:connId/entity-tree", ctrl.MuxHandler("entities", h, nil))
	service.LogInfo("mount", "ctrl", "Connection", "action", "Entities", "route", "GET /api/v1/connections/:connId/entity-tree", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewLatencyConnectionContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Latency(rctx)
	}
	h = handleSecurity("jwt", h, "api:enterprise")
	h = handleConnectionOrigin(h)
	service.Mux.Handle("GET", "/api/v1/connections/:connId/latency", ctrl.MuxHandler("latency", h, nil))
	service.LogInfo("mount", "ctrl", "Connection", "action", "Latency", "route", "GET /api/v1/connections/:connId/latency", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewNamespacesConnectionContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Namespaces(rctx)
	}
	h = handleSecurity("jwt", h, "api:general")
	h = handleConnectionOrigin(h)
	service.Mux.Handle("GET", "/api/v1/connections/:connId/namespaces", ctrl.MuxHandler("namespaces", h, nil))
	service.LogInfo("mount", "ctrl", "Connection", "action", "Namespaces", "route", "GET /api/v1/connections/:connId/namespaces", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewQueryConnectionContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Query(rctx)
	}
	h = handleSecurity("jwt", h, "api:general")
	h = handleConnectionOrigin(h)
	service.Mux.Handle("GET", "/api/v1/connections", ctrl.MuxHandler("query", h, nil))
	service.LogInfo("mount", "ctrl", "Connection", "action", "Query", "route", "GET /api/v1/connections", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewSaveConnectionContext(ctx, req, service)
		if err != nil {
			return err
		}
		// Build the payload
		if rawPayload := goa.ContextRequest(ctx).Payload; rawPayload != nil {
			rctx.Payload = rawPayload.(*SaveConnectionPayload)
		} else {
			return goa.MissingPayloadError()
		}
		return ctrl.Save(rctx)
	}
	h = handleSecurity("jwt", h, "api:general")
	h = handleConnectionOrigin(h)
	service.Mux.Handle("POST", "/api/v1/connections", ctrl.MuxHandler("save", h, unmarshalSaveConnectionPayload))
	service.LogInfo("mount", "ctrl", "Connection", "action", "Save", "route", "POST /api/v1/connections", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewSetConfigConnectionContext(ctx, req, service)
		if err != nil {
			return err
		}
		// Build the payload
		if rawPayload := goa.ContextRequest(ctx).Payload; rawPayload != nil {
			rctx.Payload = rawPayload.(*SetConfigConnectionPayload)
		} else {
			return goa.MissingPayloadError()
		}
		return ctrl.SetConfig(rctx)
	}
	h = handleSecurity("jwt", h, "api:enterprise")
	h = handleConnectionOrigin(h)
	service.Mux.Handle("POST", "/api/v1/connections/:connId/config", ctrl.MuxHandler("set config", h, unmarshalSetConfigConnectionPayload))
	service.LogInfo("mount", "ctrl", "Connection", "action", "SetConfig", "route", "POST /api/v1/connections/:connId/config", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewShowConnectionContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Show(rctx)
	}
	h = handleSecurity("jwt", h, "api:general")
	h = handleConnectionOrigin(h)
	service.Mux.Handle("GET", "/api/v1/connections/:connId", ctrl.MuxHandler("show", h, nil))
	service.LogInfo("mount", "ctrl", "Connection", "action", "Show", "route", "GET /api/v1/connections/:connId", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewThroughputConnectionContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Throughput(rctx)
	}
	h = handleSecurity("jwt", h, "api:general")
	h = handleConnectionOrigin(h)
	service.Mux.Handle("GET", "/api/v1/connections/:connId/throughput", ctrl.MuxHandler("throughput", h, nil))
	service.LogInfo("mount", "ctrl", "Connection", "action", "Throughput", "route", "GET /api/v1/connections/:connId/throughput", "security", "jwt")
}

// handleConnectionOrigin applies the CORS response headers corresponding to the origin.
func handleConnectionOrigin(h goa.Handler) goa.Handler {

	return func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		origin := req.Header.Get("Origin")
		if origin == "" {
			// Not a CORS request
			return h(ctx, rw, req)
		}
		if cors.MatchOrigin(origin, "*") {
			ctx = goa.WithLogContext(ctx, "origin", origin)
			rw.Header().Set("Access-Control-Allow-Origin", origin)
			rw.Header().Set("Access-Control-Expose-Headers", "X-Time")
			rw.Header().Set("Access-Control-Max-Age", "600")
			rw.Header().Set("Access-Control-Allow-Credentials", "true")
			if acrm := req.Header.Get("Access-Control-Request-Method"); acrm != "" {
				// We are handling a preflight request
				rw.Header().Set("Access-Control-Allow-Methods", "GET, POST, DELETE")
				rw.Header().Set("Access-Control-Allow-Headers", "*")
			}
			return h(ctx, rw, req)
		}

		return h(ctx, rw, req)
	}
}

// unmarshalAddNodeConnectionPayload unmarshals the request body into the context request data Payload field.
func unmarshalAddNodeConnectionPayload(ctx context.Context, service *goa.Service, req *http.Request) error {
	payload := &addNodeConnectionPayload{}
	if err := service.DecodeRequest(req, payload); err != nil {
		return err
	}
	if err := payload.Validate(); err != nil {
		// Initialize payload with private data structure so it can be logged
		goa.ContextRequest(ctx).Payload = payload
		return err
	}
	goa.ContextRequest(ctx).Payload = payload.Publicize()
	return nil
}

// unmarshalConnectConnectionPayload unmarshals the request body into the context request data Payload field.
func unmarshalConnectConnectionPayload(ctx context.Context, service *goa.Service, req *http.Request) error {
	payload := &connectConnectionPayload{}
	if err := service.DecodeRequest(req, payload); err != nil {
		return err
	}
	if err := payload.Validate(); err != nil {
		// Initialize payload with private data structure so it can be logged
		goa.ContextRequest(ctx).Payload = payload
		return err
	}
	goa.ContextRequest(ctx).Payload = payload.Publicize()
	return nil
}

// unmarshalSaveConnectionPayload unmarshals the request body into the context request data Payload field.
func unmarshalSaveConnectionPayload(ctx context.Context, service *goa.Service, req *http.Request) error {
	payload := &saveConnectionPayload{}
	if err := service.DecodeRequest(req, payload); err != nil {
		return err
	}
	if err := payload.Validate(); err != nil {
		// Initialize payload with private data structure so it can be logged
		goa.ContextRequest(ctx).Payload = payload
		return err
	}
	goa.ContextRequest(ctx).Payload = payload.Publicize()
	return nil
}

// unmarshalSetConfigConnectionPayload unmarshals the request body into the context request data Payload field.
func unmarshalSetConfigConnectionPayload(ctx context.Context, service *goa.Service, req *http.Request) error {
	payload := &setConfigConnectionPayload{}
	if err := service.DecodeRequest(req, payload); err != nil {
		return err
	}
	if err := payload.Validate(); err != nil {
		// Initialize payload with private data structure so it can be logged
		goa.ContextRequest(ctx).Payload = payload
		return err
	}
	goa.ContextRequest(ctx).Payload = payload.Publicize()
	return nil
}

// DbRoleController is the controller interface for the DbRole actions.
type DbRoleController interface {
	goa.Muxer
	Delete(*DeleteDbRoleContext) error
	Query(*QueryDbRoleContext) error
	Save(*SaveDbRoleContext) error
}

// MountDbRoleController "mounts" a DbRole resource controller on the given service.
func MountDbRoleController(service *goa.Service, ctrl DbRoleController) {
	initService(service)
	var h goa.Handler
	service.Mux.Handle("OPTIONS", "/api/v1/connections/:connId/roles/:role", ctrl.MuxHandler("preflight", handleDbRoleOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/connections/:connId/roles", ctrl.MuxHandler("preflight", handleDbRoleOrigin(cors.HandlePreflight()), nil))

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewDeleteDbRoleContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Delete(rctx)
	}
	h = handleSecurity("jwt", h, "api:enterprise")
	h = handleDbRoleOrigin(h)
	service.Mux.Handle("DELETE", "/api/v1/connections/:connId/roles/:role", ctrl.MuxHandler("delete", h, nil))
	service.LogInfo("mount", "ctrl", "DbRole", "action", "Delete", "route", "DELETE /api/v1/connections/:connId/roles/:role", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewQueryDbRoleContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Query(rctx)
	}
	h = handleSecurity("jwt", h, "api:enterprise")
	h = handleDbRoleOrigin(h)
	service.Mux.Handle("GET", "/api/v1/connections/:connId/roles", ctrl.MuxHandler("query", h, nil))
	service.LogInfo("mount", "ctrl", "DbRole", "action", "Query", "route", "GET /api/v1/connections/:connId/roles", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewSaveDbRoleContext(ctx, req, service)
		if err != nil {
			return err
		}
		// Build the payload
		if rawPayload := goa.ContextRequest(ctx).Payload; rawPayload != nil {
			rctx.Payload = rawPayload.(*SaveDbRolePayload)
		} else {
			return goa.MissingPayloadError()
		}
		return ctrl.Save(rctx)
	}
	h = handleSecurity("jwt", h, "api:enterprise")
	h = handleDbRoleOrigin(h)
	service.Mux.Handle("POST", "/api/v1/connections/:connId/roles", ctrl.MuxHandler("save", h, unmarshalSaveDbRolePayload))
	service.LogInfo("mount", "ctrl", "DbRole", "action", "Save", "route", "POST /api/v1/connections/:connId/roles", "security", "jwt")
}

// handleDbRoleOrigin applies the CORS response headers corresponding to the origin.
func handleDbRoleOrigin(h goa.Handler) goa.Handler {

	return func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		origin := req.Header.Get("Origin")
		if origin == "" {
			// Not a CORS request
			return h(ctx, rw, req)
		}
		if cors.MatchOrigin(origin, "*") {
			ctx = goa.WithLogContext(ctx, "origin", origin)
			rw.Header().Set("Access-Control-Allow-Origin", origin)
			rw.Header().Set("Access-Control-Expose-Headers", "X-Time")
			rw.Header().Set("Access-Control-Max-Age", "600")
			rw.Header().Set("Access-Control-Allow-Credentials", "true")
			if acrm := req.Header.Get("Access-Control-Request-Method"); acrm != "" {
				// We are handling a preflight request
				rw.Header().Set("Access-Control-Allow-Methods", "GET, POST, DELETE")
				rw.Header().Set("Access-Control-Allow-Headers", "*")
			}
			return h(ctx, rw, req)
		}

		return h(ctx, rw, req)
	}
}

// unmarshalSaveDbRolePayload unmarshals the request body into the context request data Payload field.
func unmarshalSaveDbRolePayload(ctx context.Context, service *goa.Service, req *http.Request) error {
	payload := &saveDbRolePayload{}
	if err := service.DecodeRequest(req, payload); err != nil {
		return err
	}
	if err := payload.Validate(); err != nil {
		// Initialize payload with private data structure so it can be logged
		goa.ContextRequest(ctx).Payload = payload
		return err
	}
	goa.ContextRequest(ctx).Payload = payload.Publicize()
	return nil
}

// DbUserController is the controller interface for the DbUser actions.
type DbUserController interface {
	goa.Muxer
	Delete(*DeleteDbUserContext) error
	Query(*QueryDbUserContext) error
	Save(*SaveDbUserContext) error
	Show(*ShowDbUserContext) error
}

// MountDbUserController "mounts" a DbUser resource controller on the given service.
func MountDbUserController(service *goa.Service, ctrl DbUserController) {
	initService(service)
	var h goa.Handler
	service.Mux.Handle("OPTIONS", "/api/v1/connections/:connId/users/:username", ctrl.MuxHandler("preflight", handleDbUserOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/connections/:connId/users", ctrl.MuxHandler("preflight", handleDbUserOrigin(cors.HandlePreflight()), nil))

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewDeleteDbUserContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Delete(rctx)
	}
	h = handleSecurity("jwt", h, "api:enterprise")
	h = handleDbUserOrigin(h)
	service.Mux.Handle("DELETE", "/api/v1/connections/:connId/users/:username", ctrl.MuxHandler("delete", h, nil))
	service.LogInfo("mount", "ctrl", "DbUser", "action", "Delete", "route", "DELETE /api/v1/connections/:connId/users/:username", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewQueryDbUserContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Query(rctx)
	}
	h = handleSecurity("jwt", h, "api:enterprise")
	h = handleDbUserOrigin(h)
	service.Mux.Handle("GET", "/api/v1/connections/:connId/users", ctrl.MuxHandler("query", h, nil))
	service.LogInfo("mount", "ctrl", "DbUser", "action", "Query", "route", "GET /api/v1/connections/:connId/users", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewSaveDbUserContext(ctx, req, service)
		if err != nil {
			return err
		}
		// Build the payload
		if rawPayload := goa.ContextRequest(ctx).Payload; rawPayload != nil {
			rctx.Payload = rawPayload.(*SaveDbUserPayload)
		} else {
			return goa.MissingPayloadError()
		}
		return ctrl.Save(rctx)
	}
	h = handleSecurity("jwt", h, "api:enterprise")
	h = handleDbUserOrigin(h)
	service.Mux.Handle("POST", "/api/v1/connections/:connId/users", ctrl.MuxHandler("save", h, unmarshalSaveDbUserPayload))
	service.LogInfo("mount", "ctrl", "DbUser", "action", "Save", "route", "POST /api/v1/connections/:connId/users", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewShowDbUserContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Show(rctx)
	}
	h = handleSecurity("jwt", h, "api:enterprise")
	h = handleDbUserOrigin(h)
	service.Mux.Handle("GET", "/api/v1/connections/:connId/users/:username", ctrl.MuxHandler("show", h, nil))
	service.LogInfo("mount", "ctrl", "DbUser", "action", "Show", "route", "GET /api/v1/connections/:connId/users/:username", "security", "jwt")
}

// handleDbUserOrigin applies the CORS response headers corresponding to the origin.
func handleDbUserOrigin(h goa.Handler) goa.Handler {

	return func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		origin := req.Header.Get("Origin")
		if origin == "" {
			// Not a CORS request
			return h(ctx, rw, req)
		}
		if cors.MatchOrigin(origin, "*") {
			ctx = goa.WithLogContext(ctx, "origin", origin)
			rw.Header().Set("Access-Control-Allow-Origin", origin)
			rw.Header().Set("Access-Control-Expose-Headers", "X-Time")
			rw.Header().Set("Access-Control-Max-Age", "600")
			rw.Header().Set("Access-Control-Allow-Credentials", "true")
			if acrm := req.Header.Get("Access-Control-Request-Method"); acrm != "" {
				// We are handling a preflight request
				rw.Header().Set("Access-Control-Allow-Methods", "GET, POST, DELETE")
				rw.Header().Set("Access-Control-Allow-Headers", "*")
			}
			return h(ctx, rw, req)
		}

		return h(ctx, rw, req)
	}
}

// unmarshalSaveDbUserPayload unmarshals the request body into the context request data Payload field.
func unmarshalSaveDbUserPayload(ctx context.Context, service *goa.Service, req *http.Request) error {
	payload := &saveDbUserPayload{}
	if err := service.DecodeRequest(req, payload); err != nil {
		return err
	}
	if err := payload.Validate(); err != nil {
		// Initialize payload with private data structure so it can be logged
		goa.ContextRequest(ctx).Payload = payload
		return err
	}
	goa.ContextRequest(ctx).Payload = payload.Publicize()
	return nil
}

// IndexController is the controller interface for the Index actions.
type IndexController interface {
	goa.Muxer
	Drop(*DropIndexContext) error
	Query(*QueryIndexContext) error
	Save(*SaveIndexContext) error
	Show(*ShowIndexContext) error
}

// MountIndexController "mounts" a Index resource controller on the given service.
func MountIndexController(service *goa.Service, ctrl IndexController) {
	initService(service)
	var h goa.Handler
	service.Mux.Handle("OPTIONS", "/api/v1/connections/:connId/indexes/:name", ctrl.MuxHandler("preflight", handleIndexOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/connections/:connId/indexes", ctrl.MuxHandler("preflight", handleIndexOrigin(cors.HandlePreflight()), nil))

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewDropIndexContext(ctx, req, service)
		if err != nil {
			return err
		}
		// Build the payload
		if rawPayload := goa.ContextRequest(ctx).Payload; rawPayload != nil {
			rctx.Payload = rawPayload.(*DropIndexPayload)
		} else {
			return goa.MissingPayloadError()
		}
		return ctrl.Drop(rctx)
	}
	h = handleSecurity("jwt", h, "api:general")
	h = handleIndexOrigin(h)
	service.Mux.Handle("DELETE", "/api/v1/connections/:connId/indexes/:name", ctrl.MuxHandler("drop", h, unmarshalDropIndexPayload))
	service.LogInfo("mount", "ctrl", "Index", "action", "Drop", "route", "DELETE /api/v1/connections/:connId/indexes/:name", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewQueryIndexContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Query(rctx)
	}
	h = handleSecurity("jwt", h, "api:general")
	h = handleIndexOrigin(h)
	service.Mux.Handle("GET", "/api/v1/connections/:connId/indexes", ctrl.MuxHandler("query", h, nil))
	service.LogInfo("mount", "ctrl", "Index", "action", "Query", "route", "GET /api/v1/connections/:connId/indexes", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewSaveIndexContext(ctx, req, service)
		if err != nil {
			return err
		}
		// Build the payload
		if rawPayload := goa.ContextRequest(ctx).Payload; rawPayload != nil {
			rctx.Payload = rawPayload.(*SaveIndexPayload)
		} else {
			return goa.MissingPayloadError()
		}
		return ctrl.Save(rctx)
	}
	h = handleSecurity("jwt", h, "api:general")
	h = handleIndexOrigin(h)
	service.Mux.Handle("POST", "/api/v1/connections/:connId/indexes", ctrl.MuxHandler("save", h, unmarshalSaveIndexPayload))
	service.LogInfo("mount", "ctrl", "Index", "action", "Save", "route", "POST /api/v1/connections/:connId/indexes", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewShowIndexContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Show(rctx)
	}
	h = handleSecurity("jwt", h, "api:general")
	h = handleIndexOrigin(h)
	service.Mux.Handle("GET", "/api/v1/connections/:connId/indexes/:name", ctrl.MuxHandler("show", h, nil))
	service.LogInfo("mount", "ctrl", "Index", "action", "Show", "route", "GET /api/v1/connections/:connId/indexes/:name", "security", "jwt")
}

// handleIndexOrigin applies the CORS response headers corresponding to the origin.
func handleIndexOrigin(h goa.Handler) goa.Handler {

	return func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		origin := req.Header.Get("Origin")
		if origin == "" {
			// Not a CORS request
			return h(ctx, rw, req)
		}
		if cors.MatchOrigin(origin, "*") {
			ctx = goa.WithLogContext(ctx, "origin", origin)
			rw.Header().Set("Access-Control-Allow-Origin", origin)
			rw.Header().Set("Access-Control-Expose-Headers", "X-Time")
			rw.Header().Set("Access-Control-Max-Age", "600")
			rw.Header().Set("Access-Control-Allow-Credentials", "true")
			if acrm := req.Header.Get("Access-Control-Request-Method"); acrm != "" {
				// We are handling a preflight request
				rw.Header().Set("Access-Control-Allow-Methods", "GET, POST, DELETE")
				rw.Header().Set("Access-Control-Allow-Headers", "*")
			}
			return h(ctx, rw, req)
		}

		return h(ctx, rw, req)
	}
}

// unmarshalDropIndexPayload unmarshals the request body into the context request data Payload field.
func unmarshalDropIndexPayload(ctx context.Context, service *goa.Service, req *http.Request) error {
	payload := &dropIndexPayload{}
	if err := service.DecodeRequest(req, payload); err != nil {
		return err
	}
	if err := payload.Validate(); err != nil {
		// Initialize payload with private data structure so it can be logged
		goa.ContextRequest(ctx).Payload = payload
		return err
	}
	goa.ContextRequest(ctx).Payload = payload.Publicize()
	return nil
}

// unmarshalSaveIndexPayload unmarshals the request body into the context request data Payload field.
func unmarshalSaveIndexPayload(ctx context.Context, service *goa.Service, req *http.Request) error {
	payload := &saveIndexPayload{}
	if err := service.DecodeRequest(req, payload); err != nil {
		return err
	}
	if err := payload.Validate(); err != nil {
		// Initialize payload with private data structure so it can be logged
		goa.ContextRequest(ctx).Payload = payload
		return err
	}
	goa.ContextRequest(ctx).Payload = payload.Publicize()
	return nil
}

// ModuleController is the controller interface for the Module actions.
type ModuleController interface {
	goa.Muxer
	Drop(*DropModuleContext) error
	Query(*QueryModuleContext) error
	Save(*SaveModuleContext) error
	Show(*ShowModuleContext) error
}

// MountModuleController "mounts" a Module resource controller on the given service.
func MountModuleController(service *goa.Service, ctrl ModuleController) {
	initService(service)
	var h goa.Handler
	service.Mux.Handle("OPTIONS", "/api/v1/connections/:connId/modules/:name", ctrl.MuxHandler("preflight", handleModuleOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/connections/:connId/modules", ctrl.MuxHandler("preflight", handleModuleOrigin(cors.HandlePreflight()), nil))

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewDropModuleContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Drop(rctx)
	}
	h = handleSecurity("jwt", h, "api:general")
	h = handleModuleOrigin(h)
	service.Mux.Handle("DELETE", "/api/v1/connections/:connId/modules/:name", ctrl.MuxHandler("drop", h, nil))
	service.LogInfo("mount", "ctrl", "Module", "action", "Drop", "route", "DELETE /api/v1/connections/:connId/modules/:name", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewQueryModuleContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Query(rctx)
	}
	h = handleSecurity("jwt", h, "api:general")
	h = handleModuleOrigin(h)
	service.Mux.Handle("GET", "/api/v1/connections/:connId/modules", ctrl.MuxHandler("query", h, nil))
	service.LogInfo("mount", "ctrl", "Module", "action", "Query", "route", "GET /api/v1/connections/:connId/modules", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewSaveModuleContext(ctx, req, service)
		if err != nil {
			return err
		}
		// Build the payload
		if rawPayload := goa.ContextRequest(ctx).Payload; rawPayload != nil {
			rctx.Payload = rawPayload.(*SaveModulePayload)
		} else {
			return goa.MissingPayloadError()
		}
		return ctrl.Save(rctx)
	}
	h = handleSecurity("jwt", h, "api:general")
	h = handleModuleOrigin(h)
	service.Mux.Handle("POST", "/api/v1/connections/:connId/modules", ctrl.MuxHandler("save", h, unmarshalSaveModulePayload))
	service.LogInfo("mount", "ctrl", "Module", "action", "Save", "route", "POST /api/v1/connections/:connId/modules", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewShowModuleContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Show(rctx)
	}
	h = handleSecurity("jwt", h, "api:general")
	h = handleModuleOrigin(h)
	service.Mux.Handle("GET", "/api/v1/connections/:connId/modules/:name", ctrl.MuxHandler("show", h, nil))
	service.LogInfo("mount", "ctrl", "Module", "action", "Show", "route", "GET /api/v1/connections/:connId/modules/:name", "security", "jwt")
}

// handleModuleOrigin applies the CORS response headers corresponding to the origin.
func handleModuleOrigin(h goa.Handler) goa.Handler {

	return func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		origin := req.Header.Get("Origin")
		if origin == "" {
			// Not a CORS request
			return h(ctx, rw, req)
		}
		if cors.MatchOrigin(origin, "*") {
			ctx = goa.WithLogContext(ctx, "origin", origin)
			rw.Header().Set("Access-Control-Allow-Origin", origin)
			rw.Header().Set("Access-Control-Expose-Headers", "X-Time")
			rw.Header().Set("Access-Control-Max-Age", "600")
			rw.Header().Set("Access-Control-Allow-Credentials", "true")
			if acrm := req.Header.Get("Access-Control-Request-Method"); acrm != "" {
				// We are handling a preflight request
				rw.Header().Set("Access-Control-Allow-Methods", "GET, POST, DELETE")
				rw.Header().Set("Access-Control-Allow-Headers", "*")
			}
			return h(ctx, rw, req)
		}

		return h(ctx, rw, req)
	}
}

// unmarshalSaveModulePayload unmarshals the request body into the context request data Payload field.
func unmarshalSaveModulePayload(ctx context.Context, service *goa.Service, req *http.Request) error {
	payload := &saveModulePayload{}
	if err := service.DecodeRequest(req, payload); err != nil {
		return err
	}
	if err := payload.Validate(); err != nil {
		// Initialize payload with private data structure so it can be logged
		goa.ContextRequest(ctx).Payload = payload
		return err
	}
	goa.ContextRequest(ctx).Payload = payload.Publicize()
	return nil
}

// NamespaceController is the controller interface for the Namespace actions.
type NamespaceController interface {
	goa.Muxer
	Config(*ConfigNamespaceContext) error
	Drop(*DropNamespaceContext) error
	Latency(*LatencyNamespaceContext) error
	Query(*QueryNamespaceContext) error
	SetConfig(*SetConfigNamespaceContext) error
	Show(*ShowNamespaceContext) error
	Throughput(*ThroughputNamespaceContext) error
}

// MountNamespaceController "mounts" a Namespace resource controller on the given service.
func MountNamespaceController(service *goa.Service, ctrl NamespaceController) {
	initService(service)
	var h goa.Handler
	service.Mux.Handle("OPTIONS", "/api/v1/connections/:connId/nodes/:node/namespaces/:namespace/config", ctrl.MuxHandler("preflight", handleNamespaceOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/connections/:connId/nodes/:node/namespaces/:namespace", ctrl.MuxHandler("preflight", handleNamespaceOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/connections/:connId/nodes/:node/namespaces/:namespace/latency", ctrl.MuxHandler("preflight", handleNamespaceOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/connections/:connId/nodes/:node/namespaces", ctrl.MuxHandler("preflight", handleNamespaceOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/connections/:connId/nodes/:node/namespaces/:namespace/throughput", ctrl.MuxHandler("preflight", handleNamespaceOrigin(cors.HandlePreflight()), nil))

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewConfigNamespaceContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Config(rctx)
	}
	h = handleSecurity("jwt", h, "api:enterprise")
	h = handleNamespaceOrigin(h)
	service.Mux.Handle("GET", "/api/v1/connections/:connId/nodes/:node/namespaces/:namespace/config", ctrl.MuxHandler("config", h, nil))
	service.LogInfo("mount", "ctrl", "Namespace", "action", "Config", "route", "GET /api/v1/connections/:connId/nodes/:node/namespaces/:namespace/config", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewDropNamespaceContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Drop(rctx)
	}
	h = handleSecurity("jwt", h, "api:general")
	h = handleNamespaceOrigin(h)
	service.Mux.Handle("DELETE", "/api/v1/connections/:connId/nodes/:node/namespaces/:namespace", ctrl.MuxHandler("drop", h, nil))
	service.LogInfo("mount", "ctrl", "Namespace", "action", "Drop", "route", "DELETE /api/v1/connections/:connId/nodes/:node/namespaces/:namespace", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewLatencyNamespaceContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Latency(rctx)
	}
	h = handleSecurity("jwt", h, "api:enterprise")
	h = handleNamespaceOrigin(h)
	service.Mux.Handle("GET", "/api/v1/connections/:connId/nodes/:node/namespaces/:namespace/latency", ctrl.MuxHandler("latency", h, nil))
	service.LogInfo("mount", "ctrl", "Namespace", "action", "Latency", "route", "GET /api/v1/connections/:connId/nodes/:node/namespaces/:namespace/latency", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewQueryNamespaceContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Query(rctx)
	}
	h = handleSecurity("jwt", h, "api:general")
	h = handleNamespaceOrigin(h)
	service.Mux.Handle("GET", "/api/v1/connections/:connId/nodes/:node/namespaces", ctrl.MuxHandler("query", h, nil))
	service.LogInfo("mount", "ctrl", "Namespace", "action", "Query", "route", "GET /api/v1/connections/:connId/nodes/:node/namespaces", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewSetConfigNamespaceContext(ctx, req, service)
		if err != nil {
			return err
		}
		// Build the payload
		if rawPayload := goa.ContextRequest(ctx).Payload; rawPayload != nil {
			rctx.Payload = rawPayload.(*SetConfigNamespacePayload)
		} else {
			return goa.MissingPayloadError()
		}
		return ctrl.SetConfig(rctx)
	}
	h = handleSecurity("jwt", h, "api:enterprise")
	h = handleNamespaceOrigin(h)
	service.Mux.Handle("POST", "/api/v1/connections/:connId/nodes/:node/namespaces/:namespace/config", ctrl.MuxHandler("set config", h, unmarshalSetConfigNamespacePayload))
	service.LogInfo("mount", "ctrl", "Namespace", "action", "SetConfig", "route", "POST /api/v1/connections/:connId/nodes/:node/namespaces/:namespace/config", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewShowNamespaceContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Show(rctx)
	}
	h = handleSecurity("jwt", h, "api:general")
	h = handleNamespaceOrigin(h)
	service.Mux.Handle("GET", "/api/v1/connections/:connId/nodes/:node/namespaces/:namespace", ctrl.MuxHandler("show", h, nil))
	service.LogInfo("mount", "ctrl", "Namespace", "action", "Show", "route", "GET /api/v1/connections/:connId/nodes/:node/namespaces/:namespace", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewThroughputNamespaceContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Throughput(rctx)
	}
	h = handleSecurity("jwt", h, "api:general")
	h = handleNamespaceOrigin(h)
	service.Mux.Handle("GET", "/api/v1/connections/:connId/nodes/:node/namespaces/:namespace/throughput", ctrl.MuxHandler("throughput", h, nil))
	service.LogInfo("mount", "ctrl", "Namespace", "action", "Throughput", "route", "GET /api/v1/connections/:connId/nodes/:node/namespaces/:namespace/throughput", "security", "jwt")
}

// handleNamespaceOrigin applies the CORS response headers corresponding to the origin.
func handleNamespaceOrigin(h goa.Handler) goa.Handler {

	return func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		origin := req.Header.Get("Origin")
		if origin == "" {
			// Not a CORS request
			return h(ctx, rw, req)
		}
		if cors.MatchOrigin(origin, "*") {
			ctx = goa.WithLogContext(ctx, "origin", origin)
			rw.Header().Set("Access-Control-Allow-Origin", origin)
			rw.Header().Set("Access-Control-Expose-Headers", "X-Time")
			rw.Header().Set("Access-Control-Max-Age", "600")
			rw.Header().Set("Access-Control-Allow-Credentials", "true")
			if acrm := req.Header.Get("Access-Control-Request-Method"); acrm != "" {
				// We are handling a preflight request
				rw.Header().Set("Access-Control-Allow-Methods", "GET, POST, DELETE")
				rw.Header().Set("Access-Control-Allow-Headers", "*")
			}
			return h(ctx, rw, req)
		}

		return h(ctx, rw, req)
	}
}

// unmarshalSetConfigNamespacePayload unmarshals the request body into the context request data Payload field.
func unmarshalSetConfigNamespacePayload(ctx context.Context, service *goa.Service, req *http.Request) error {
	payload := &setConfigNamespacePayload{}
	if err := service.DecodeRequest(req, payload); err != nil {
		return err
	}
	if err := payload.Validate(); err != nil {
		// Initialize payload with private data structure so it can be logged
		goa.ContextRequest(ctx).Payload = payload
		return err
	}
	goa.ContextRequest(ctx).Payload = payload.Publicize()
	return nil
}

// NodeController is the controller interface for the Node actions.
type NodeController interface {
	goa.Muxer
	Config(*ConfigNodeContext) error
	Jobs(*JobsNodeContext) error
	KillJob(*KillJobNodeContext) error
	Latency(*LatencyNodeContext) error
	SetConfig(*SetConfigNodeContext) error
	Show(*ShowNodeContext) error
	Throughput(*ThroughputNodeContext) error
}

// MountNodeController "mounts" a Node resource controller on the given service.
func MountNodeController(service *goa.Service, ctrl NodeController) {
	initService(service)
	var h goa.Handler
	service.Mux.Handle("OPTIONS", "/api/v1/connections/:connId/nodes/:node/config", ctrl.MuxHandler("preflight", handleNodeOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/connections/:connId/nodes/:node/jobs", ctrl.MuxHandler("preflight", handleNodeOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/connections/:connId/nodes/:node/jobs/:trid", ctrl.MuxHandler("preflight", handleNodeOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/connections/:connId/nodes/:node/latency", ctrl.MuxHandler("preflight", handleNodeOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/connections/:connId/nodes/:node", ctrl.MuxHandler("preflight", handleNodeOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/connections/:connId/nodes/:node/throughput", ctrl.MuxHandler("preflight", handleNodeOrigin(cors.HandlePreflight()), nil))

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewConfigNodeContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Config(rctx)
	}
	h = handleSecurity("jwt", h, "api:enterprise")
	h = handleNodeOrigin(h)
	service.Mux.Handle("GET", "/api/v1/connections/:connId/nodes/:node/config", ctrl.MuxHandler("config", h, nil))
	service.LogInfo("mount", "ctrl", "Node", "action", "Config", "route", "GET /api/v1/connections/:connId/nodes/:node/config", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewJobsNodeContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Jobs(rctx)
	}
	h = handleSecurity("jwt", h, "api:general")
	h = handleNodeOrigin(h)
	service.Mux.Handle("GET", "/api/v1/connections/:connId/nodes/:node/jobs", ctrl.MuxHandler("jobs", h, nil))
	service.LogInfo("mount", "ctrl", "Node", "action", "Jobs", "route", "GET /api/v1/connections/:connId/nodes/:node/jobs", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewKillJobNodeContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.KillJob(rctx)
	}
	h = handleSecurity("jwt", h, "api:enterprise")
	h = handleNodeOrigin(h)
	service.Mux.Handle("GET", "/api/v1/connections/:connId/nodes/:node/jobs/:trid", ctrl.MuxHandler("kill-job", h, nil))
	service.LogInfo("mount", "ctrl", "Node", "action", "KillJob", "route", "GET /api/v1/connections/:connId/nodes/:node/jobs/:trid", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewLatencyNodeContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Latency(rctx)
	}
	h = handleSecurity("jwt", h, "api:enterprise")
	h = handleNodeOrigin(h)
	service.Mux.Handle("GET", "/api/v1/connections/:connId/nodes/:node/latency", ctrl.MuxHandler("latency", h, nil))
	service.LogInfo("mount", "ctrl", "Node", "action", "Latency", "route", "GET /api/v1/connections/:connId/nodes/:node/latency", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewSetConfigNodeContext(ctx, req, service)
		if err != nil {
			return err
		}
		// Build the payload
		if rawPayload := goa.ContextRequest(ctx).Payload; rawPayload != nil {
			rctx.Payload = rawPayload.(*SetConfigNodePayload)
		} else {
			return goa.MissingPayloadError()
		}
		return ctrl.SetConfig(rctx)
	}
	h = handleSecurity("jwt", h, "api:enterprise")
	h = handleNodeOrigin(h)
	service.Mux.Handle("POST", "/api/v1/connections/:connId/nodes/:node/config", ctrl.MuxHandler("set config", h, unmarshalSetConfigNodePayload))
	service.LogInfo("mount", "ctrl", "Node", "action", "SetConfig", "route", "POST /api/v1/connections/:connId/nodes/:node/config", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewShowNodeContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Show(rctx)
	}
	h = handleSecurity("jwt", h, "api:general")
	h = handleNodeOrigin(h)
	service.Mux.Handle("GET", "/api/v1/connections/:connId/nodes/:node", ctrl.MuxHandler("show", h, nil))
	service.LogInfo("mount", "ctrl", "Node", "action", "Show", "route", "GET /api/v1/connections/:connId/nodes/:node", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewThroughputNodeContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Throughput(rctx)
	}
	h = handleSecurity("jwt", h, "api:general")
	h = handleNodeOrigin(h)
	service.Mux.Handle("GET", "/api/v1/connections/:connId/nodes/:node/throughput", ctrl.MuxHandler("throughput", h, nil))
	service.LogInfo("mount", "ctrl", "Node", "action", "Throughput", "route", "GET /api/v1/connections/:connId/nodes/:node/throughput", "security", "jwt")
}

// handleNodeOrigin applies the CORS response headers corresponding to the origin.
func handleNodeOrigin(h goa.Handler) goa.Handler {

	return func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		origin := req.Header.Get("Origin")
		if origin == "" {
			// Not a CORS request
			return h(ctx, rw, req)
		}
		if cors.MatchOrigin(origin, "*") {
			ctx = goa.WithLogContext(ctx, "origin", origin)
			rw.Header().Set("Access-Control-Allow-Origin", origin)
			rw.Header().Set("Access-Control-Expose-Headers", "X-Time")
			rw.Header().Set("Access-Control-Max-Age", "600")
			rw.Header().Set("Access-Control-Allow-Credentials", "true")
			if acrm := req.Header.Get("Access-Control-Request-Method"); acrm != "" {
				// We are handling a preflight request
				rw.Header().Set("Access-Control-Allow-Methods", "GET, POST, DELETE")
				rw.Header().Set("Access-Control-Allow-Headers", "*")
			}
			return h(ctx, rw, req)
		}

		return h(ctx, rw, req)
	}
}

// unmarshalSetConfigNodePayload unmarshals the request body into the context request data Payload field.
func unmarshalSetConfigNodePayload(ctx context.Context, service *goa.Service, req *http.Request) error {
	payload := &setConfigNodePayload{}
	if err := service.DecodeRequest(req, payload); err != nil {
		return err
	}
	if err := payload.Validate(); err != nil {
		// Initialize payload with private data structure so it can be logged
		goa.ContextRequest(ctx).Payload = payload
		return err
	}
	goa.ContextRequest(ctx).Payload = payload.Publicize()
	return nil
}

// NotificationController is the controller interface for the Notification actions.
type NotificationController interface {
	goa.Muxer
	Query(*QueryNotificationContext) error
}

// MountNotificationController "mounts" a Notification resource controller on the given service.
func MountNotificationController(service *goa.Service, ctrl NotificationController) {
	initService(service)
	var h goa.Handler
	service.Mux.Handle("OPTIONS", "/api/v1/connections/:connId/notifications", ctrl.MuxHandler("preflight", handleNotificationOrigin(cors.HandlePreflight()), nil))

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewQueryNotificationContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Query(rctx)
	}
	h = handleSecurity("jwt", h, "api:enterprise")
	h = handleNotificationOrigin(h)
	service.Mux.Handle("GET", "/api/v1/connections/:connId/notifications", ctrl.MuxHandler("query", h, nil))
	service.LogInfo("mount", "ctrl", "Notification", "action", "Query", "route", "GET /api/v1/connections/:connId/notifications", "security", "jwt")
}

// handleNotificationOrigin applies the CORS response headers corresponding to the origin.
func handleNotificationOrigin(h goa.Handler) goa.Handler {

	return func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		origin := req.Header.Get("Origin")
		if origin == "" {
			// Not a CORS request
			return h(ctx, rw, req)
		}
		if cors.MatchOrigin(origin, "*") {
			ctx = goa.WithLogContext(ctx, "origin", origin)
			rw.Header().Set("Access-Control-Allow-Origin", origin)
			rw.Header().Set("Access-Control-Expose-Headers", "X-Time")
			rw.Header().Set("Access-Control-Max-Age", "600")
			rw.Header().Set("Access-Control-Allow-Credentials", "true")
			if acrm := req.Header.Get("Access-Control-Request-Method"); acrm != "" {
				// We are handling a preflight request
				rw.Header().Set("Access-Control-Allow-Methods", "GET, POST, DELETE")
				rw.Header().Set("Access-Control-Allow-Headers", "*")
			}
			return h(ctx, rw, req)
		}

		return h(ctx, rw, req)
	}
}

// PublicController is the controller interface for the Public actions.
type PublicController interface {
	goa.Muxer
	goa.FileServer
}

// MountPublicController "mounts" a Public resource controller on the given service.
func MountPublicController(service *goa.Service, ctrl PublicController) {
	initService(service)
	var h goa.Handler
	service.Mux.Handle("OPTIONS", "/static/*filepath", ctrl.MuxHandler("preflight", handlePublicOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/*filepath", ctrl.MuxHandler("preflight", handlePublicOrigin(cors.HandlePreflight()), nil))

	h = ctrl.FileHandler("/static/*filepath", "static_v5/")
	h = handlePublicOrigin(h)
	service.Mux.Handle("GET", "/static/*filepath", ctrl.MuxHandler("serve", h, nil))
	service.LogInfo("mount", "ctrl", "Public", "files", "static_v5/", "route", "GET /static/*filepath")

	h = ctrl.FileHandler("/*filepath", "static_v5/")
	h = handlePublicOrigin(h)
	service.Mux.Handle("GET", "/*filepath", ctrl.MuxHandler("serve", h, nil))
	service.LogInfo("mount", "ctrl", "Public", "files", "static_v5/", "route", "GET /*filepath")

	h = ctrl.FileHandler("/static/", "static_v5/index.html")
	h = handlePublicOrigin(h)
	service.Mux.Handle("GET", "/static/", ctrl.MuxHandler("serve", h, nil))
	service.LogInfo("mount", "ctrl", "Public", "files", "static_v5/index.html", "route", "GET /static/")

	h = ctrl.FileHandler("/", "static_v5/index.html")
	h = handlePublicOrigin(h)
	service.Mux.Handle("GET", "/", ctrl.MuxHandler("serve", h, nil))
	service.LogInfo("mount", "ctrl", "Public", "files", "static_v5/index.html", "route", "GET /")
}

// handlePublicOrigin applies the CORS response headers corresponding to the origin.
func handlePublicOrigin(h goa.Handler) goa.Handler {

	return func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		origin := req.Header.Get("Origin")
		if origin == "" {
			// Not a CORS request
			return h(ctx, rw, req)
		}
		if cors.MatchOrigin(origin, "*") {
			ctx = goa.WithLogContext(ctx, "origin", origin)
			rw.Header().Set("Access-Control-Allow-Origin", origin)
			rw.Header().Set("Access-Control-Allow-Credentials", "false")
			if acrm := req.Header.Get("Access-Control-Request-Method"); acrm != "" {
				// We are handling a preflight request
				rw.Header().Set("Access-Control-Allow-Methods", "GET, OPTIONS")
			}
			return h(ctx, rw, req)
		}

		return h(ctx, rw, req)
	}
}

// RestoreController is the controller interface for the Restore actions.
type RestoreController interface {
	goa.Muxer
	Create(*CreateRestoreContext) error
	Progress(*ProgressRestoreContext) error
}

// MountRestoreController "mounts" a Restore resource controller on the given service.
func MountRestoreController(service *goa.Service, ctrl RestoreController) {
	initService(service)
	var h goa.Handler
	service.Mux.Handle("OPTIONS", "/api/v1/connections/:connId/restores", ctrl.MuxHandler("preflight", handleRestoreOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/connections/:connId/restores/progress", ctrl.MuxHandler("preflight", handleRestoreOrigin(cors.HandlePreflight()), nil))

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewCreateRestoreContext(ctx, req, service)
		if err != nil {
			return err
		}
		// Build the payload
		if rawPayload := goa.ContextRequest(ctx).Payload; rawPayload != nil {
			rctx.Payload = rawPayload.(*CreateRestorePayload)
		} else {
			return goa.MissingPayloadError()
		}
		return ctrl.Create(rctx)
	}
	h = handleSecurity("jwt", h, "api:enterprise")
	h = handleRestoreOrigin(h)
	service.Mux.Handle("POST", "/api/v1/connections/:connId/restores", ctrl.MuxHandler("create", h, unmarshalCreateRestorePayload))
	service.LogInfo("mount", "ctrl", "Restore", "action", "Create", "route", "POST /api/v1/connections/:connId/restores", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewProgressRestoreContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Progress(rctx)
	}
	h = handleSecurity("jwt", h, "api:enterprise")
	h = handleRestoreOrigin(h)
	service.Mux.Handle("GET", "/api/v1/connections/:connId/restores/progress", ctrl.MuxHandler("progress", h, nil))
	service.LogInfo("mount", "ctrl", "Restore", "action", "Progress", "route", "GET /api/v1/connections/:connId/restores/progress", "security", "jwt")
}

// handleRestoreOrigin applies the CORS response headers corresponding to the origin.
func handleRestoreOrigin(h goa.Handler) goa.Handler {

	return func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		origin := req.Header.Get("Origin")
		if origin == "" {
			// Not a CORS request
			return h(ctx, rw, req)
		}
		if cors.MatchOrigin(origin, "*") {
			ctx = goa.WithLogContext(ctx, "origin", origin)
			rw.Header().Set("Access-Control-Allow-Origin", origin)
			rw.Header().Set("Access-Control-Expose-Headers", "X-Time")
			rw.Header().Set("Access-Control-Max-Age", "600")
			rw.Header().Set("Access-Control-Allow-Credentials", "true")
			if acrm := req.Header.Get("Access-Control-Request-Method"); acrm != "" {
				// We are handling a preflight request
				rw.Header().Set("Access-Control-Allow-Methods", "GET, POST, DELETE")
				rw.Header().Set("Access-Control-Allow-Headers", "*")
			}
			return h(ctx, rw, req)
		}

		return h(ctx, rw, req)
	}
}

// unmarshalCreateRestorePayload unmarshals the request body into the context request data Payload field.
func unmarshalCreateRestorePayload(ctx context.Context, service *goa.Service, req *http.Request) error {
	payload := &createRestorePayload{}
	if err := service.DecodeRequest(req, payload); err != nil {
		return err
	}
	if err := payload.Validate(); err != nil {
		// Initialize payload with private data structure so it can be logged
		goa.ContextRequest(ctx).Payload = payload
		return err
	}
	goa.ContextRequest(ctx).Payload = payload.Publicize()
	return nil
}

// SetController is the controller interface for the Set actions.
type SetController interface {
	goa.Muxer
	Drop(*DropSetContext) error
	Query(*QuerySetContext) error
	Show(*ShowSetContext) error
}

// MountSetController "mounts" a Set resource controller on the given service.
func MountSetController(service *goa.Service, ctrl SetController) {
	initService(service)
	var h goa.Handler
	service.Mux.Handle("OPTIONS", "/api/v1/connections/:connId/nodes/:node/namespaces/:namespace/sets/:setName", ctrl.MuxHandler("preflight", handleSetOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/connections/:connId/nodes/:node/namespaces/:namespace/sets", ctrl.MuxHandler("preflight", handleSetOrigin(cors.HandlePreflight()), nil))

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewDropSetContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Drop(rctx)
	}
	h = handleSecurity("jwt", h, "api:general")
	h = handleSetOrigin(h)
	service.Mux.Handle("DELETE", "/api/v1/connections/:connId/nodes/:node/namespaces/:namespace/sets/:setName", ctrl.MuxHandler("drop", h, nil))
	service.LogInfo("mount", "ctrl", "Set", "action", "Drop", "route", "DELETE /api/v1/connections/:connId/nodes/:node/namespaces/:namespace/sets/:setName", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewQuerySetContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Query(rctx)
	}
	h = handleSecurity("jwt", h, "api:general")
	h = handleSetOrigin(h)
	service.Mux.Handle("GET", "/api/v1/connections/:connId/nodes/:node/namespaces/:namespace/sets", ctrl.MuxHandler("query", h, nil))
	service.LogInfo("mount", "ctrl", "Set", "action", "Query", "route", "GET /api/v1/connections/:connId/nodes/:node/namespaces/:namespace/sets", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewShowSetContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Show(rctx)
	}
	h = handleSecurity("jwt", h, "api:general")
	h = handleSetOrigin(h)
	service.Mux.Handle("GET", "/api/v1/connections/:connId/nodes/:node/namespaces/:namespace/sets/:setName", ctrl.MuxHandler("show", h, nil))
	service.LogInfo("mount", "ctrl", "Set", "action", "Show", "route", "GET /api/v1/connections/:connId/nodes/:node/namespaces/:namespace/sets/:setName", "security", "jwt")
}

// handleSetOrigin applies the CORS response headers corresponding to the origin.
func handleSetOrigin(h goa.Handler) goa.Handler {

	return func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		origin := req.Header.Get("Origin")
		if origin == "" {
			// Not a CORS request
			return h(ctx, rw, req)
		}
		if cors.MatchOrigin(origin, "*") {
			ctx = goa.WithLogContext(ctx, "origin", origin)
			rw.Header().Set("Access-Control-Allow-Origin", origin)
			rw.Header().Set("Access-Control-Expose-Headers", "X-Time")
			rw.Header().Set("Access-Control-Max-Age", "600")
			rw.Header().Set("Access-Control-Allow-Credentials", "true")
			if acrm := req.Header.Get("Access-Control-Request-Method"); acrm != "" {
				// We are handling a preflight request
				rw.Header().Set("Access-Control-Allow-Methods", "GET, POST, DELETE")
				rw.Header().Set("Access-Control-Allow-Headers", "*")
			}
			return h(ctx, rw, req)
		}

		return h(ctx, rw, req)
	}
}

// SwaggerController is the controller interface for the Swagger actions.
type SwaggerController interface {
	goa.Muxer
	goa.FileServer
}

// MountSwaggerController "mounts" a Swagger resource controller on the given service.
func MountSwaggerController(service *goa.Service, ctrl SwaggerController) {
	initService(service)
	var h goa.Handler
	service.Mux.Handle("OPTIONS", "/swagger.json", ctrl.MuxHandler("preflight", handleSwaggerOrigin(cors.HandlePreflight()), nil))

	h = ctrl.FileHandler("/swagger.json", "swagger/swagger.json")
	h = handleSwaggerOrigin(h)
	service.Mux.Handle("GET", "/swagger.json", ctrl.MuxHandler("serve", h, nil))
	service.LogInfo("mount", "ctrl", "Swagger", "files", "swagger/swagger.json", "route", "GET /swagger.json")
}

// handleSwaggerOrigin applies the CORS response headers corresponding to the origin.
func handleSwaggerOrigin(h goa.Handler) goa.Handler {

	return func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		origin := req.Header.Get("Origin")
		if origin == "" {
			// Not a CORS request
			return h(ctx, rw, req)
		}
		if cors.MatchOrigin(origin, "*") {
			ctx = goa.WithLogContext(ctx, "origin", origin)
			rw.Header().Set("Access-Control-Allow-Origin", origin)
			rw.Header().Set("Access-Control-Allow-Credentials", "false")
			if acrm := req.Header.Get("Access-Control-Request-Method"); acrm != "" {
				// We are handling a preflight request
				rw.Header().Set("Access-Control-Allow-Methods", "GET")
			}
			return h(ctx, rw, req)
		}

		return h(ctx, rw, req)
	}
}

// UserController is the controller interface for the User actions.
type UserController interface {
	goa.Muxer
	Delete(*DeleteUserContext) error
	Get(*GetUserContext) error
	Query(*QueryUserContext) error
	Save(*SaveUserContext) error
}

// MountUserController "mounts" a User resource controller on the given service.
func MountUserController(service *goa.Service, ctrl UserController) {
	initService(service)
	var h goa.Handler
	service.Mux.Handle("OPTIONS", "/api/v1/users/:username", ctrl.MuxHandler("preflight", handleUserOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/users", ctrl.MuxHandler("preflight", handleUserOrigin(cors.HandlePreflight()), nil))

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewDeleteUserContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Delete(rctx)
	}
	h = handleSecurity("jwt", h, "api:admin")
	h = handleUserOrigin(h)
	service.Mux.Handle("DELETE", "/api/v1/users/:username", ctrl.MuxHandler("delete", h, nil))
	service.LogInfo("mount", "ctrl", "User", "action", "Delete", "route", "DELETE /api/v1/users/:username", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewGetUserContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Get(rctx)
	}
	h = handleSecurity("jwt", h, "api:admin")
	h = handleUserOrigin(h)
	service.Mux.Handle("GET", "/api/v1/users/:username", ctrl.MuxHandler("get", h, nil))
	service.LogInfo("mount", "ctrl", "User", "action", "Get", "route", "GET /api/v1/users/:username", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewQueryUserContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Query(rctx)
	}
	h = handleSecurity("jwt", h, "api:admin")
	h = handleUserOrigin(h)
	service.Mux.Handle("GET", "/api/v1/users", ctrl.MuxHandler("query", h, nil))
	service.LogInfo("mount", "ctrl", "User", "action", "Query", "route", "GET /api/v1/users", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewSaveUserContext(ctx, req, service)
		if err != nil {
			return err
		}
		// Build the payload
		if rawPayload := goa.ContextRequest(ctx).Payload; rawPayload != nil {
			rctx.Payload = rawPayload.(*SaveUserPayload)
		} else {
			return goa.MissingPayloadError()
		}
		return ctrl.Save(rctx)
	}
	h = handleSecurity("jwt", h, "api:admin")
	h = handleUserOrigin(h)
	service.Mux.Handle("POST", "/api/v1/users", ctrl.MuxHandler("save", h, unmarshalSaveUserPayload))
	service.LogInfo("mount", "ctrl", "User", "action", "Save", "route", "POST /api/v1/users", "security", "jwt")
}

// handleUserOrigin applies the CORS response headers corresponding to the origin.
func handleUserOrigin(h goa.Handler) goa.Handler {

	return func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		origin := req.Header.Get("Origin")
		if origin == "" {
			// Not a CORS request
			return h(ctx, rw, req)
		}
		if cors.MatchOrigin(origin, "*") {
			ctx = goa.WithLogContext(ctx, "origin", origin)
			rw.Header().Set("Access-Control-Allow-Origin", origin)
			rw.Header().Set("Access-Control-Expose-Headers", "X-Time")
			rw.Header().Set("Access-Control-Max-Age", "600")
			rw.Header().Set("Access-Control-Allow-Credentials", "true")
			if acrm := req.Header.Get("Access-Control-Request-Method"); acrm != "" {
				// We are handling a preflight request
				rw.Header().Set("Access-Control-Allow-Methods", "GET, POST, DELETE")
				rw.Header().Set("Access-Control-Allow-Headers", "*")
			}
			return h(ctx, rw, req)
		}

		return h(ctx, rw, req)
	}
}

// unmarshalSaveUserPayload unmarshals the request body into the context request data Payload field.
func unmarshalSaveUserPayload(ctx context.Context, service *goa.Service, req *http.Request) error {
	payload := &saveUserPayload{}
	if err := service.DecodeRequest(req, payload); err != nil {
		return err
	}
	if err := payload.Validate(); err != nil {
		// Initialize payload with private data structure so it can be logged
		goa.ContextRequest(ctx).Payload = payload
		return err
	}
	goa.ContextRequest(ctx).Payload = payload.Publicize()
	return nil
}
